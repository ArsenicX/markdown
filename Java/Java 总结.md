## 入门

- 成员变量不赋值就可以直接使用，int、byte等类型为0，boolean为fault，引用类型为null
局部变量必须先赋值，才能使用
<br>
- 运算符优先级：单目 > 算术(加减乘除) > 关系(==、>=...) > 赋值
 - 单目运算符，比如`a*-b`：表示的是先对b取相反数，然后再与a相乘。单目优先级最高
 - 多个关系运算符中，==和!=最低。例如：`5>3==6>4`表示的是`(5>3)==(6>4)`，最后返回的是1 
<br>
- `switch-case`
虽然样子和功能看上去类似`if else`嵌套
但是用debug断点就可以看到，`if else`是从第一条if开始，一个一个向下判断是否匹配，费时费力；而`switch-case`是直接跳到对应的`case`语句<br><br>
这样带来的好处就是，`switch-case`的效率不会被候选匹配项的数量影响
> 常见用法：成绩评定级别（90分以上为A，80-89为B...）
> 
>     switch（score/10）{
>     case 10:
>     case 9: printf("A");
>     ...}
>     


- final：
    - 修饰类--------表示其不能被继承，即最终类
    - 修饰方法-----表示其不能被重写，即最终方法
    - 修饰变量-----表示其不能被修改，即常量

- abstract：
    - 如果当前类有抽象方法，或继承自一个抽象类/抽象接口，但没有全部实现该类/该接口的抽象方法，则必须定义为抽象类
抽象类可以包含成员变量及构造方法，但不能被实例化，即不能new
    - 不能用来修饰成员变量和构造方法
    - 不能用private修饰，不能和static，final，native同时修饰同一方法

- [Java 里的 abstract 和 final 关键字](https://blog.csdn.net/nvd11/article/details/18706087)

## 进阶

- 
继承 & 多态 & 接口： *instanceof* 类来判断该引用型变量所指向的对象是否属于该类或该类的子类

1. 继承：
子类的修饰权限和父类必须要保持一致或更加公开
在构造子类对象的时候，会首先调用父类的无参构造方法；如果父类没有无参构造方法，则报错
如果要在子类的构造方法中明确写出调用基类方法super( )的话，则需要写在子类构造方法的**第一行**
2. 多态：
子类方法的可访问性和父类必须要保持一致或更加公开
父类的私有方法不能被重写，即使子类中定义了一个同名的方法，也是一个新的方法，和父类方法无关
不能重写静态方法
3. 接口：
接口中定义的成员变量都是 static & final
接口中定义的方法默认是、也只能是public类型；同时也只能是抽象方法（abstract，不能有方法体）、默认方法（必须用default修饰）或类方法（static）
<br>
- 异常：
1. Try  Catch：
    用竖线使一个try catch捕获多个异常，但是这种方式捕捉到的异常不能重新赋值，只能是e
    `try{...}
    catch(NumberFormatException  | ArithmeeticException e) {...}`
即使catch中有return，代码也会执行finally中的语句，除非catch中有System.exit( )（退出应用程序）
执行内部的try如果没有遇到匹配的catch块，则检查外部的catch块

2. Throw/ Throws：
throw用于try语句中，在可能出现异常的语句中 `throw new Exception("... ...")`
throws用于方法外部，如果自定义的方法可能会抛出异常，则方法名外加上 `throws IOException,Exception`....，然后在调用该方法的地方使用catch捕获

3. 自定义异常：如果总是在运行时产生异常，且不易预测在什么时候发生异常，则定义为RuntimeException；否则定义为Exception
